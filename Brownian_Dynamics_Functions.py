import numpy as np
from functools import partial
import scipy.sparse
import time

# Try to import numba
try:
  from numba import njit, prange
except ImportError:
  print('numba not found')

def stochastic_forcing_lanczos(factor = 1.0, 
                               tolerance = 1e-06, 
                               max_iter = 1000, 
                               dim = None, 
                               mobility = None, 
                               mobility_mult = None,
                               L_mult = None,
                               z = None,
                               print_residual = False):
  '''
  Compute the stochastic forcing (factor * M^{1/2} * z) using
  the Lanczos algorithm, see Krylov subspace methods for 
  computing hydrodynamic interactions in Brownian dynamics simulations, 
  T. Ando et al. The Journal of Chemical Physics 137, 064106 (2012) 
  doi: 10.1063/1.4742347 and subsequent papers by Yousef Saad.

  The noise generated by this function should be the same 
  (to within tolerance) than the noise generated by the function
  stochastic_forcing_eig_symm.  
  
  Input: 
  factor = the prefactor, in general something like sqrt(2*k_B*T*dt)
  tolerance = the tolerance to determine convergence.
  max_iter = maximum number of iterations allowed.
  dim = The dimension of the noise. If it is not passed dim = len(z).
  print_residual = (Optional, default False) If True, it prints the iteration number and the 
                   residual every iteration.
  z = (Optional) the random vector.
  mobility = the mobility matrix. You can pass it like a list of lists or
             a list of numpy arrays. It is not used if mobility_mult
             is passed (see below).
  mobility_mult = function that computes a matrix vector product 
                  with the mobility matrix. It allows to use matrix
                  free methods.
  L_mult = function that computes a matrix vector product 
           between the preconditioner matrix L and the noise generated by
           the Lanczos algorithm. L should obey the relation
           M \approx L*L^T.
  
  Output:
  The code returns 
  (stochastic_forcing, iterations) 
  with
  stochastic_forcing = (factor * M^{1/2} * z)
  iterations = total number of iterations.
  '''

  # Define array dimension 
  if dim is None:
    dim = len(z)

  if factor == 0.0:
    return (np.zeros(dim), 0)

  # Create matrix v (initial column is random)
  # Note: v will have shape (iteration, dim);
  # in the standard notation used in the Lanczos
  # scheme v will be the matrix V^T
  if z is None:
    v = np.random.randn(1, dim)
  else:
    v = np.copy(np.reshape(z, (1, dim)))

  # Normalize v
  v_norm = np.linalg.norm(v[0])
  v[0] /= v_norm 

  # Create list for the data of the symmetric tridiagonal matrix h 
  h_sup = []
  h_diag = []

  # Create vectors noise
  noise = np.zeros(dim) 
  noise_old = np.zeros(dim) 

  # Iterate until convergence or max_iter
  for i in range(max_iter+1):
    # w = mobility * v[i]
    if mobility is None:
      w = np.reshape(mobility_mult(v[i]), dim)
    else:
      w = np.dot(mobility, v[i])

    # w = w - h[i-1, i] * v[i-1]   
    if i > 0:
      w = w - h_sup[i-1] * v[i-1] 

    # h(i, i) = <w, v[i]> 
    h_diag.append( np.dot(w, v[i]) ) 

    # w = w - h(i, i)*v(i)
    w = w - h_diag[i] * v[i]

    # h(i+1, i) = h(i, i+1) = <w, w>
    h_sup.append( np.linalg.norm(w) )

    # w = w/normw;
    if h_sup[i] > 0:
      w /= h_sup[i]
    else:
      w[0] = 1.0
    
    # Build tridiagonal matrix h
    h = h_diag * np.eye(len(h_diag)) + h_sup * np.eye(len(h_sup), k=-1) + (h_sup * np.eye(len(h_sup), k=-1)).T

    # Compute eigenvalues and eigenvectors of h
    # IMPORTANT: this is NOT optimized for tridiagonal matrices
    eig_values, eig_vectors = np.linalg.eigh(h)

    # Compute the square root of positive eigenvalues set to zero otherwise
    eig_values_sqrt = np.array([np.sqrt(x) if x > 0 else 0 for x in eig_values])
    
    # Create vector e_1
    e_1 = np.zeros(len(eig_values))
    e_1[0] = 1.0

    # Compute noise approximation as in Eq. 16 of Ando et al. 2012
    noise = np.dot(v.T, np.dot(eig_vectors, v_norm * factor * eig_values_sqrt * np.dot(eig_vectors.T, e_1)))

    # Orthogonalize base with modified Gram-Schmidt;
    # we use that norm(v[i])=norm(w)=1
    for row in v:
      w = w - (np.dot(row, w)) * row 

    # v(i+1) = w
    v = np.concatenate([v, [w]])

    if i > 0:
      # Compute difference with noise of previous iteration
      noise_old_norm = np.linalg.norm(noise_old)
      diff_norm = np.linalg.norm(noise - noise_old)

      # (Optional) Print residual
      if i > 0 and print_residual is True:
        if i == 1:
          print('lanczos =  0 1')
        print('lanczos = ', i, diff_norm / noise_old_norm)

      # Check convergence and return if difference < tolerance
      if diff_norm / np.maximum(noise_old_norm, np.finfo(float).eps) < tolerance:
        if L_mult is None:
          return (noise, i)
        else:
          return (np.reshape(L_mult(noise), dim), i)
          
    # Save noise to check convergence in the next iteration
    noise_old = np.copy(noise)

  # Return UNCONVERGED noise
  if L_mult is None:
    return (noise, max_iter)
  else:
    return (np.reshape(L_mult(noise), dim), max_iter)



def Euler_Maruyama(F_calc,r_vectors,Mdot,dt,KbT):
  ''' 
  Evolves particle postions, r_vectors, according to the Langevin equation 
  dr/dt = M*F + KbT*Div(M) + sqrt(2*KbT)*M^(1/2)*dW

  discertization is done using the explicit EM-RFD sheme
  r^{n+1}-r^{n} = M^n*F^n*dt + KbT*Div(M^n)*dt + sqrt(2*KbT*dt)*(M^n)^(1/2)*W

  This function outputs r^{n+1}
  '''
  # calculate forces and then deterministic velocities M^n*F^n
  F_n = F_calc(r_vectors)
  U_det_n = Mdot(F_n,r_vectors)

  # calculate (M^n)^(1/2)*W using Lanczos with tolerance = 0.1*dt (since EM is first order)
  W_n = np.random.normal(0.0, 1.0, len(F_n))
  tol = 1e-3 #0.1*dt
  Mhalf_W_n, its = stochastic_forcing_lanczos(factor = 1.0, 
                                        max_iter=1000, 
                                        tolerance=tol, 
                                        mobility_mult=(lambda force: Mdot(force,r_vectors)),
                                        z = W_n)
  
  # calculate thermal drift term using Random FInite Difference
  # Div(M^n) = (1/delta) * (M(X^n + delta/2*W) - M(X^n - delta/2*W)) * W
  # delta = 1e-3 is a good choice in general but it can be changed
  rfd_delta = 1e-3
  W_rfd = np.random.normal(0.0, 1.0, len(F_n))
  Div_M_n = (1.0/rfd_delta)*(Mdot(W_rfd,r_vectors+0.5*rfd_delta*W_rfd) - Mdot(W_rfd,r_vectors-0.5*rfd_delta*W_rfd))

  # update positions according to langevin dynamics
  r_vectors_new = r_vectors + dt*U_det_n + dt*KbT*Div_M_n + np.sqrt(2.0*dt*KbT)*Mhalf_W_n

  return r_vectors_new

def Stochastic_Trap(F_calc,r_vectors,Mdot,dt,KbT):
  ''' 
  Evolves particle postions, r_vectors, according to the Langevin equation 
  dr/dt = M*F + KbT*Div(M) + sqrt(2*KbT)*M^(1/2)*dW

  discertization is done using the explicit EM-RFD sheme
  r^{p}-r^{n} = dt*M^n*F^n + KbT*Div(M^n)*dt + sqrt(2*KbT*dt)*(M^n)^(1/2)*W
  r^{n+1}-r^{n} = (dt/2)*(M^n*F^n + M^p*F^p) + KbT*Div(M^n)*dt + sqrt(2*KbT*dt)*(M^n)^(1/2)*W

  This function outputs r^{n+1}
  '''
  # calculate forces and then deterministic velocities M^n*F^n
  start = time.time()
  F_n = F_calc(r_vectors)
  print("Force calc time: "+str(time.time()-start)+" (s)")
  start = time.time()
  U_det_n = Mdot(F_n,r_vectors)
  print("Det hydro. time: "+str(time.time()-start)+" (s)")

  # calculate (M^n)^(1/2)*W using Lanczos with tolerance = 0.1*dt (since EM is first order)
  start = time.time()
  W_n = np.random.normal(0.0, 1.0, len(F_n))
  tol = 1e-3 #0.1*dt
  Mhalf_W_n, its = stochastic_forcing_lanczos(factor = 1.0, 
                                        max_iter=1000, 
                                        tolerance=tol, 
                                        mobility_mult=(lambda force: Mdot(force,r_vectors)),
                                        z = W_n)
  print("M^(1/2)*W time: "+str(time.time()-start)+" (s)")
  # calculate thermal drift term using Random FInite Difference
  # Div(M^n) = (1/delta) * (M(X^n + delta/2*W) - M(X^n - delta/2*W)) * W
  # delta = 1e-3 is a good choice in general but it can be changed
  rfd_delta = 1e-3
  W_rfd = np.random.normal(0.0, 1.0, len(F_n))
  Div_M_n = (1.0/rfd_delta)*(Mdot(W_rfd,r_vectors+0.5*rfd_delta*W_rfd) - Mdot(W_rfd,r_vectors-0.5*rfd_delta*W_rfd))

  # update positions to predicted step
  r_vectors_pred = r_vectors + dt*U_det_n + dt*KbT*Div_M_n + np.sqrt(2.0*dt*KbT)*Mhalf_W_n

  # calculate corrector forces and then deterministic velocities M^p*F^p
  F_p = F_calc(r_vectors_pred)
  U_det_p = Mdot(F_p,r_vectors_pred)

  # update positions according to langevin dynamics
  r_vectors_new = r_vectors + 0.5*dt*(U_det_n+U_det_p) + dt*KbT*Div_M_n + np.sqrt(2.0*dt*KbT)*Mhalf_W_n

  return r_vectors_new


def project_to_periodic_image(r, L):
  '''
  Project a vector r to the minimal image representation
  centered around (0,0,0) and of size L=(Lx, Ly, Lz). If 
  any dimension of L is equal or smaller than zero the 
  box is assumed to be infinite in that direction.
  '''
  if L is not None:
    for i in range(3):
      if(L[i] > 0):
        r[i] = r[i] - int(r[i] / L[i] + 0.5 * (int(r[i]>0) - int(r[i]<0))) * L[i]
  return r




# Mtt:
@njit(parallel=True, fastmath=True)
def single_wall_mobility_trans_times_force_numba(force, r_vectors, eta, a, L):
  ''' 
  Returns the product of the mobility at the blob level to the force 
  on the blobs. Mobility for particles above a single wall.  
  
  This function uses numba.
  '''
  # Variables
  N = r_vectors.size // 3
  r_vectors = r_vectors.reshape(N, 3)
  force = force.reshape(N, 3)
  u = np.zeros((N, 3))
  fourOverThree = 4.0 / 3.0
  inva = 1.0 / a
  norm_fact_f = 1.0 / (8.0 * np.pi * eta * a)

  # Determine if the space is pseudo-periodic in any dimension
  # We use a extended unit cell of length L=3*(Lx, Ly, Lz)
  periodic_x = 0
  periodic_y = 0
  periodic_z = 0 
  Lx = L[0]
  Ly = L[1]
  Lz = L[2]
  if Lx > 0:
    periodic_x = 1
  if Ly > 0:
    periodic_y = 1
  if Lz > 0:
    periodic_z = 1
    
  rx_vec = np.copy(r_vectors[:,0])
  ry_vec = np.copy(r_vectors[:,1])
  rz_vec = np.copy(r_vectors[:,2])
  fx_vec = np.copy(force[:,0])
  fy_vec = np.copy(force[:,1])
  fz_vec = np.copy(force[:,2])
  ux_vec = np.zeros(N)
  uy_vec = np.zeros(N)
  uz_vec = np.zeros(N)
    
  # Loop over image boxes and then over particles
  for i in prange(N):
    rxi = rx_vec[i]
    ryi = ry_vec[i]
    rzi = rz_vec[i]
    for boxX in range(-periodic_x, periodic_x+1):
      for boxY in range(-periodic_y, periodic_y+1):
        for boxZ in range(-periodic_z, periodic_z+1):
          for j in range(N):
	  
            # Compute vector between particles i and j
            rx = rxi - rx_vec[j]
            ry = ryi - ry_vec[j]
            rz = rzi - rz_vec[j]

            # Project a vector r to the extended unit cell
            # centered around (0,0,0) and of size L=3*(Lx, Ly, Lz). If 
            # any dimension of L is equal or smaller than zero the 
            # box is assumed to be infinite in that direction.
            if Lx > 0:
              rx = rx - int(rx / Lx + 0.5 * (int(rx>0) - int(rx<0))) * Lx
              rx = rx + boxX * Lx
            if Ly > 0:
              ry = ry - int(ry / Ly + 0.5 * (int(ry>0) - int(ry<0))) * Ly
              ry = ry + boxY * Ly 
            if Lz > 0:
              rz = rz - int(rz / Lz + 0.5 * (int(rz>0) - int(rz<0))) * Lz
              rz = rz + boxZ * Lz            
               
            # 1. Compute mobility for pair i-j, if i==j use self-interation
            j_image = j
            if boxX != 0 or boxY != 0 or boxZ != 0:
              j_image = -1           

            rx = rx * inva 
            ry = ry * inva
            rz = rz * inva
            if i == j_image:
              Mxx = fourOverThree
              Mxy = 0
              Mxz = 0
              Myy = Mxx
              Myz = 0
              Mzz = Mxx           
            else:
              # Normalize distance with hydrodynamic radius
              r2 = rx*rx + ry*ry + rz*rz
              r = np.sqrt(r2)
              
              # TODO: We should not divide by zero 
              invr = 1.0 / r
              invr2 = invr * invr

              if r > 2:
                c1 = 1.0 + 2.0 / (3.0 * r2)
                c2 = (1.0 - 2.0 * invr2) * invr2
                Mxx = (c1 + c2*rx*rx) * invr
                Mxy = (     c2*rx*ry) * invr
                Mxz = (     c2*rx*rz) * invr
                Myy = (c1 + c2*ry*ry) * invr
                Myz = (     c2*ry*rz) * invr
                Mzz = (c1 + c2*rz*rz) * invr 
              else:
                c1 = fourOverThree * (1.0 - 0.28125 * r) # 9/32 = 0.28125
                c2 = fourOverThree * 0.09375 * invr      # 3/32 = 0.09375
                Mxx = c1 + c2 * rx*rx 
                Mxy =      c2 * rx*ry 
                Mxz =      c2 * rx*rz 
                Myy = c1 + c2 * ry*ry 
                Myz =      c2 * ry*rz 
                Mzz = c1 + c2 * rz*rz 
                
            Myx = Mxy
            Mzx = Mxz
            Mzy = Myz

            # Wall correction
            rz = (rzi + rz_vec[j]) * inva
            hj = rz_vec[j] * inva

            if i == j_image:
              invZi = 1.0 / hj
              invZi3 = invZi * invZi * invZi
              invZi5 = invZi3 * invZi * invZi
            
              Mxx += -(9.0 * invZi - 2.0 * invZi3 + invZi5 ) / 12.0
              Myy += -(9.0 * invZi - 2.0 * invZi3 + invZi5 ) / 12.0
              Mzz += -(9.0 * invZi - 4.0 * invZi3 + invZi5 ) / 6.0   
            else:
              h_hat = hj / rz
              invR = 1.0 / np.sqrt(rx*rx + ry*ry + rz*rz)
              ex = rx * invR
              ey = ry * invR
              ez = rz * invR
              invR3 = invR * invR * invR
              invR5 = invR3 * invR * invR
                  
              fact1 = -(3.0*(1.0+2.0*h_hat*(1.0-h_hat)*ez*ez) * invR + 2.0*(1.0-3.0*ez*ez) * invR3 - 2.0*(1.0-5.0*ez*ez) * invR5)  / 3.0
              fact2 = -(3.0*(1.0-6.0*h_hat*(1.0-h_hat)*ez*ez) * invR - 6.0*(1.0-5.0*ez*ez) * invR3 + 10.0*(1.0-7.0*ez*ez) * invR5) / 3.0
              fact3 =  ez * (3.0*h_hat*(1.0-6.0*(1.0-h_hat)*ez*ez) * invR - 6.0*(1.0-5.0*ez*ez) * invR3 + 10.0*(2.0-7.0*ez*ez) * invR5) * 2.0 / 3.0
              fact4 =  ez * (3.0*h_hat*invR - 10.0*invR5) * 2.0 / 3.0
              fact5 = -(3.0*h_hat*h_hat*ez*ez*invR + 3.0*ez*ez*invR3 + (2.0-15.0*ez*ez)*invR5) * 4.0 / 3.0
    
              Mxx += fact1 + fact2 * ex*ex
              Mxy += fact2 * ex*ey
              Mxz += fact2 * ex*ez + fact3 * ex
              Myx += fact2 * ey*ex
              Myy += fact1 + fact2 * ey*ey
              Myz += fact2 * ey*ez + fact3 * ey
              Mzx += fact2 * ez*ex + fact4 * ex
              Mzy += fact2 * ez*ey + fact4 * ey
              Mzz += fact1 + fact2 * ez*ez + fact3 * ez + fact4 * ez + fact5
	  
            # 2. Compute product M_ij * F_j           
            ux_vec[i] += (Mxx * fx_vec[j] + Mxy * fy_vec[j] + Mxz * fz_vec[j]) * norm_fact_f
            uy_vec[i] += (Myx * fx_vec[j] + Myy * fy_vec[j] + Myz * fz_vec[j]) * norm_fact_f
            uz_vec[i] += (Mzx * fx_vec[j] + Mzy * fy_vec[j] + Mzz * fz_vec[j]) * norm_fact_f

    u[i,0] = ux_vec[i]
    u[i,1] = uy_vec[i]
    u[i,2] = uz_vec[i]

  return u.flatten()



# Mtr :
@njit(parallel=True, fastmath=True)
def single_wall_mobility_trans_times_torque_numba(torque, r_vectors, eta, a, L):
  ''' 
  Returns the product of the mobility translation-rotation at the blob level to the torque 
  on the blobs. Mobility for particles on top of an infinite wall.  
  
  This function uses numba.
  '''
  # Variables
  N = r_vectors.size // 3
  r_vectors = r_vectors.reshape(N, 3)
  torque = torque.reshape(N, 3)
  u = np.zeros((N, 3))
  fourOverThree = 4.0 / 3.0
  inva = 1.0 / a
  norm_fact_f = 1.0 / (8.0 * np.pi * eta * a**2)

  # Determine if the space is pseudo-periodic in any dimension
  # We use a extended unit cell of length L=3*(Lx, Ly, Lz)
  periodic_x = 0
  periodic_y = 0 
  periodic_z = 0
  if L[0] > 0:
    periodic_x = 1
  if L[1] > 0:
    periodic_y = 1
  if L[2] > 0:
    periodic_z = 1
  
  # Loop over image boxes and then over particles
  for i in prange(N):
    for boxX in range(-periodic_x, periodic_x+1):
      for boxY in range(-periodic_y, periodic_y+1):
        for boxZ in range(-periodic_z, periodic_z+1):
          for j in range(N):
            
            # Compute vector between particles i and j
            rx = r_vectors[i,0] - r_vectors[j,0]
            ry = r_vectors[i,1] - r_vectors[j,1]
            rz = r_vectors[i,2] - r_vectors[j,2]

            # Project a vector r to the extended unit cell
            # centered around (0,0,0) and of size L=3*(Lx, Ly, Lz). If 
            # any dimension of L is equal or smaller than zero the 
            # box is assumed to be infinite in that direction.
            if L[0] > 0:
              rx = rx - int(rx / L[0] + 0.5 * (int(rx>0) - int(rx<0))) * L[0]
              rx = rx + boxX * L[0]
            if L[1] > 0:
              ry = ry - int(ry / L[1] + 0.5 * (int(ry>0) - int(ry<0))) * L[1]
              ry = ry + boxY * L[1]              
            if L[2] > 0:
              rz = rz - int(rz / L[2] + 0.5 * (int(rz>0) - int(rz<0))) * L[2]
              rz = rz + boxZ * L[2]            
               
            # 1. Compute mobility for pair i-j, if i==j use self-interation
            j_image = j
            if boxX != 0 or boxY != 0 or boxZ != 0:
              j_image = -1           

            # 1. Compute UT mobility for pair i-j
            # mobilityUTRPY(rx,ry,rz, Mxx,Mxy,Mxz,Myy,Myz,Mzz, i,j_image, invaGPU);
            rx = rx * inva 
            ry = ry * inva
            rz = rz * inva
            if i == j_image:
              Mxx = 0
              Mxy = 0
              Mxz = 0
              Myy = 0
              Myz = 0
              Mzz = 0
            else:
              # Normalize distance with hydrodynamic radius
              r2 = rx*rx + ry*ry + rz*rz
              r = np.sqrt(r2)
              r3 = r2*r
              # TODO: We should not divide by zero 
              invr3 = 1.0 / r3
              if r >= 2:
                Mxx =  0
                Mxy =  rz * invr3
                Mxz = -ry * invr3
                Myy =  0
                Myz =  rx * invr3
                Mzz =  0
              else:
                c1 = 0.5 * (1.0 - 0.375 * r) # 3/8 = 0.375
                Mxx =  0
                Mxy =  c1 * rz
                Mxz = -c1 * ry 
                Myy =  0
                Myz =  c1 * rx
                Mzz =  0

            Myx = -Mxy
            Mzx = -Mxz
            Mzy = -Myz

            # Wall correction
            # mobilityUTSingleWallCorrection(-rx/a, -ry/a, (-rz+2*x[ioffset+2])/a, Mxx,Mxy,Mxz,Myx,Myy,Myz,Mzx,Mzy, j_image,i, invaGPU, x[ioffset+2]/a);
            rx = -rx
            ry = -ry
            rz = (r_vectors[i,2] + r_vectors[j,2]) * inva
            hj = r_vectors[i,2] * inva

            if i == j_image:
              invZi = 1.0 / hj
              invZi4 = invZi**4
              Mxy -= - invZi4 * 0.125 # 3/24 = 0.125
              Myx -=   invZi4 * 0.125 # 3/24 = 0.125
            else:
              h_hat = hj / rz
              invR = 1.0 / np.sqrt(rx*rx + ry*ry + rz*rz)
              invR2 = invR * invR
              invR4 = invR2 * invR2
              ex = rx * invR
              ey = ry * invR
              ez = rz * invR
    
              fact1 =  invR2
              fact2 = (6.0 * h_hat * ez*ez * invR2 + (1.0-10.0 * ez*ez) * invR4) * 2.0
              fact3 = -ez * (3.0 * h_hat * invR2 - 5.0 * invR4) * 2.0
              fact4 = -ez * (h_hat * invR2 - invR4) * 2.0
    
              Mxx -=                       - fact3*ex*ey        
              Mxy -= - fact1*ez            + fact3*ex*ex - fact4
              Mxz -=   fact1*ey                                 
              Myx -=   fact1*ez            - fact3*ey*ey + fact4
              Myy -=                         fact3*ex*ey        
              Myz -= - fact1*ex                                 
              Mzx -= - fact1*ey - fact2*ey - fact3*ey*ez        
              Mzy -=   fact1*ex + fact2*ex + fact3*ex*ez                 
	  
            # 2. Compute product M_ij * T_j
            u[i,0] += (Mxx * torque[j,0] + Mxy * torque[j,1] + Mxz * torque[j,2]) * norm_fact_f
            u[i,1] += (Myx * torque[j,0] + Myy * torque[j,1] + Myz * torque[j,2]) * norm_fact_f
            u[i,2] += (Mzx * torque[j,0] + Mzy * torque[j,1] + Mzz * torque[j,2]) * norm_fact_f

  return u.flatten()


# Mrt:
@njit(parallel=True, fastmath=True)
def single_wall_mobility_rot_times_force_numba(force, r_vectors, eta, a, L):
  ''' 
  Returns the product of the mobility translation-rotation at the blob level to the torque 
  on the blobs. Mobility for particles in an unbounded domain, it uses
  the standard RPY tensor.  
  
  This function uses numba.
  '''
  # Variables
  N = r_vectors.size // 3
  r_vectors = r_vectors.reshape(N, 3)
  force = force.reshape(N, 3)
  u = np.zeros((N, 3))
  fourOverThree = 4.0 / 3.0
  inva = 1.0 / a
  norm_fact_f = 1.0 / (8.0 * np.pi * eta * a**2)

  # Determine if the space is pseudo-periodic in any dimension
  # We use a extended unit cell of length L=3*(Lx, Ly, Lz)
  periodic_x = 0
  periodic_y = 0 
  periodic_z = 0
  if L[0] > 0:
    periodic_x = 1
  if L[1] > 0:
    periodic_y = 1
  if L[2] > 0:
    periodic_z = 1
  
  # Loop over image boxes and then over particles
  for i in prange(N):
    for boxX in range(-periodic_x, periodic_x+1):
      for boxY in range(-periodic_y, periodic_y+1):
        for boxZ in range(-periodic_z, periodic_z+1):
          for j in range(N):
            
            # Compute vector between particles i and j
            rx = r_vectors[i,0] - r_vectors[j,0]
            ry = r_vectors[i,1] - r_vectors[j,1]
            rz = r_vectors[i,2] - r_vectors[j,2]

            # Project a vector r to the extended unit cell
            # centered around (0,0,0) and of size L=3*(Lx, Ly, Lz). If 
            # any dimension of L is equal or smaller than zero the 
            # box is assumed to be infinite in that direction.
            if L[0] > 0:
              rx = rx - int(rx / L[0] + 0.5 * (int(rx>0) - int(rx<0))) * L[0]
              rx = rx + boxX * L[0]
            if L[1] > 0:
              ry = ry - int(ry / L[1] + 0.5 * (int(ry>0) - int(ry<0))) * L[1]
              ry = ry + boxY * L[1]             
            if L[2] > 0:
              rz = rz - int(rz / L[2] + 0.5 * (int(rz>0) - int(rz<0))) * L[2]
              rz = rz + boxZ * L[2]            
               
            # 1. Compute mobility for pair i-j, if i==j use self-interation
            j_image = j
            if boxX != 0 or boxY != 0 or boxZ != 0:
              j_image = -1           

            rx = rx * inva
            ry = ry * inva
            rz = rz * inva
            if i==j_image:
              Mxx = 0
              Mxy = 0
              Mxz = 0
              Myy = 0
              Myz = 0
              Mzz = 0
            else:
              # Normalize distance with hydrodynamic radius
              r2 = rx*rx + ry*ry + rz*rz
              r = np.sqrt(r2)
              r3 = r2*r
              # TODO: We should not divide by zero 
              invr3 = 1.0 / r3
              if r >= 2.0:
                Mxx =  0
                Mxy =  rz * invr3
                Mxz = -ry * invr3
                Myy =  0
                Myz =  rx * invr3
                Mzz =  0
              else:
                c1 =  0.5 * (1.0 - 0.375 * r) # 3/8 = 0.375
                Mxx =  0
                Mxy =  c1 * rz
                Mxz = -c1 * ry 
                Myy =  0
                Myz =  c1 * rx
                Mzz =  0

            Myx = -Mxy
            Mzx = -Mxz
            Mzy = -Myz
	  
            # Wall correction
            # mobilityWFSingleWallCorrection(rx/a, ry/a, (rz+2*x[joffset+2])/a, Mxx,Mxy,Mxz,Myx,Myy,Myz,Mzx,Mzy, i,j_image, invaGPU, x[joffset+2]/a);
            rz = (r_vectors[i,2] + r_vectors[j,2]) * inva
            hj = r_vectors[j,2] * inva
            
            if i == j_image:
              invZi = 1.0 / hj
              invZi4 = invZi**4
              Mxy += -invZi4 * 0.125 # 3/24 = 0.125
              Myx +=  invZi4 * 0.125 # 3/24 = 0.125
            else:
              h_hat = hj / rz
              invR = 1.0 / np.sqrt(rx*rx + ry*ry + rz*rz)
              invR2 = invR * invR
              invR4 = invR2 * invR2
              ex = rx * invR
              ey = ry * invR
              ez = rz * invR
    
              fact1 =  invR2
              fact2 = (6.0 * h_hat * ez*ez * invR2 + (1.0 - 10.0 * ez*ez) * invR4) * 2.0
              fact3 = -ez * (3.0 * h_hat*invR2 - 5.0 * invR4) * 2.0
              fact4 = -ez * (h_hat * invR2 - invR4) * 2.0
    
              Mxx -=                       - fact3*ex*ey
              Mxy -=   fact1*ez            - fact3*ey*ey + fact4
              Mxz -= - fact1*ey - fact2*ey - fact3*ey*ez
              Myx -= - fact1*ez            + fact3*ex*ex - fact4
              Myy -=                         fact3*ex*ey
              Myz -=   fact1*ex + fact2*ex + fact3*ex*ez
              Mzx -=   fact1*ey
              Mzy -= - fact1*ex
  
            # 2. Compute product M_ij * T_j
            u[i,0] += (Mxx * force[j,0] + Mxy * force[j,1] + Mxz * force[j,2]) * norm_fact_f
            u[i,1] += (Myx * force[j,0] + Myy * force[j,1] + Myz * force[j,2]) * norm_fact_f
            u[i,2] += (Mzx * force[j,0] + Mzy * force[j,1] + Mzz * force[j,2]) * norm_fact_f

  return u.flatten()


# Mrr :
@njit(parallel=True, fastmath=True)
def single_wall_mobility_rot_times_torque_numba(torque, r_vectors, eta, a, L):
  ''' 
  Returns the product of the mobility translation-rotation at the blob level to the torque 
  on the blobs. Mobility for particles in an unbounded domain, it uses
  the standard RPY tensor.  
  
  This function uses numba.
  '''
  # Variables
  N = r_vectors.size // 3
  r_vectors = r_vectors.reshape(N, 3)
  torque = torque.reshape(N, 3)
  u = np.zeros((N, 3))
  fourOverThree = 4.0 / 3.0
  inva = 1.0 / a
  norm_fact_f = 1.0 / (8.0 * np.pi * eta * a**3)

  # Determine if the space is pseudo-periodic in any dimension 
  # We use a extended unit cell of length L=3*(Lx, Ly, Lz)
  periodic_x = 0
  periodic_y = 0 
  periodic_z = 0
  if L[0] > 0:
    periodic_x = 1
  if L[1] > 0:
    periodic_y = 1
  if L[2] > 0:
    periodic_z = 1
  
  # Loop over image boxes and then over particles
  for i in prange(N):
    for boxX in range(-periodic_x, periodic_x+1):
      for boxY in range(-periodic_y, periodic_y+1):
        for boxZ in range(-periodic_z, periodic_z+1):
          for j in range(N):
            
            # Compute vector between particles i and j
            rx = r_vectors[i,0] - r_vectors[j,0]
            ry = r_vectors[i,1] - r_vectors[j,1]
            rz = r_vectors[i,2] - r_vectors[j,2]

            # Project a vector r to the extended unit cell
            # centered around (0,0,0) and of size L=3*(Lx, Ly, Lz). If 
            # any dimension of L is equal or smaller than zero the 
            # box is assumed to be infinite in that direction.
            if L[0] > 0:
              rx = rx - int(rx / L[0] + 0.5 * (int(rx>0) - int(rx<0))) * L[0]
              rx = rx + boxX * L[0]
            if L[1] > 0:
              ry = ry - int(ry / L[1] + 0.5 * (int(ry>0) - int(ry<0))) * L[1]
              ry = ry + boxY * L[1]              
            if L[2] > 0:
              rz = rz - int(rz / L[2] + 0.5 * (int(rz>0) - int(rz<0))) * L[2]
              rz = rz + boxZ * L[2]            
               
            # 1. Compute mobility for pair i-j, if i==j use self-interation
            j_image = j
            if boxX != 0 or boxY != 0 or boxZ != 0:
              j_image = -1           

            # mobilityWTRPY(rx,ry,rz, Mxx,Mxy,Mxz,Myy,Myz,Mzz, i,j_image, invaGPU);
            rx = rx * inva
            ry = ry * inva
            rz = rz * inva
            if i==j_image:
              Mxx = 1.0
              Mxy = 0
              Mxz = 0
              Myy = Mxx
              Myz = 0
              Mzz = Mxx
            else:
              # Normalize distance with hydrodynamic radius
              r2 = rx*rx + ry*ry + rz*rz
              r = np.sqrt(r2)
              r3 = r2*r
              # TODO: We should not divide by zero 
              invr = 1.0 / r
              invr2 = 1.0 / r2
              invr3 = 1.0 / r3
              if r >= 2:
                c1 = -0.5
                c2 = 1.5 * invr2 
                Mxx = (c1 + c2*rx*rx) * invr3
                Mxy = (     c2*rx*ry) * invr3
                Mxz = (     c2*rx*rz) * invr3
                Myy = (c1 + c2*ry*ry) * invr3
                Myz = (     c2*ry*rz) * invr3
                Mzz = (c1 + c2*rz*rz) * invr3
              else:
                c1 =  (1.0 - 0.84375 * r + 0.078125 * r3) # 27/32 = 0.84375, 5/64 = 0.078125
                c2 =  0.28125 * invr - 0.046875 * r       # 9/32 = 0.28125, 3/64 = 0.046875
                Mxx = c1 + c2 * rx*rx 
                Mxy =      c2 * rx*ry 
                Mxz =      c2 * rx*rz 
                Myy = c1 + c2 * ry*ry 
                Myz =      c2 * ry*rz 
                Mzz = c1 + c2 * rz*rz 

            Myx = Mxy
            Mzx = Mxz
            Mzy = Myz
	  
            # mobilityWTSingleWallCorrection(rx/a, ry/a, (rz+2*x[joffset+2])/a, Mxx,Mxy,Mxz,Myx,Myy,Myz,Mzx,Mzy,Mzz, i,j_image, invaGPU, x[joffset+2]/a);
            rz = (r_vectors[i,2] + r_vectors[j,2]) * inva
            hj = r_vectors[j,2] * inva
            if i == j_image:
              invZi = 1.0 / hj
              invZi3 = invZi**3
              Mxx += - invZi3 * 0.3125 # 15/48 = 0.3125
              Myy += - invZi3 * 0.3125 # 15/48 = 0.3125
              Mzz += - invZi3 * 0.125  # 3/24 = 0.125
            else:
              invR = 1.0 / np.sqrt(rx*rx + ry*ry + rz*rz)
              invR3 = invR * invR * invR
              ex = rx * invR
              ey = ry * invR
              ez = rz * invR
    
              fact1 =  ((1.0 - 6.0*ez*ez) * invR3 ) * 0.5
              fact2 = -(9.0 * invR3) / 6.0
              fact3 =  (3.0 * invR3 * ez)
              fact4 =  (3.0 * invR3)
    
              Mxx += fact1 + fact2 * ex*ex + fact4 * ey*ey
              Mxy += (fact2 - fact4)* ex*ey
              Mxz += fact2 * ex*ez
              Myx += (fact2 - fact4)* ex*ey
              Myy += fact1 + fact2 * ey*ey + fact4 * ex*ex
              Myz += fact2 * ey*ez
              Mzx += fact2 * ez*ex + fact3 * ex
              Mzy += fact2 * ez*ey + fact3 * ey
              Mzz += fact1 + fact2 * ez*ez + fact3 * ez        
  
            # 2. Compute product M_ij * T_j
            u[i,0] += (Mxx * torque[j,0] + Mxy * torque[j,1] + Mxz * torque[j,2]) * norm_fact_f
            u[i,1] += (Myx * torque[j,0] + Myy * torque[j,1] + Myz * torque[j,2]) * norm_fact_f
            u[i,2] += (Mzx * torque[j,0] + Mzy * torque[j,1] + Mzz * torque[j,2]) * norm_fact_f

  return u.flatten()
